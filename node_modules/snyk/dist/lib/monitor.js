"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const snyk = require("../lib");
const api_token_1 = require("./api-token");
const request = require("./request");
const config = require("./config");
const os = require("os");
const _ = require("lodash");
const isCI = require("./is-ci");
const analytics = require("./analytics");
const types_1 = require("./types");
function monitor(root, meta, info) {
    const pkg = info.package;
    const pluginMeta = info.plugin;
    let policyPath = meta['policy-path'];
    if (!meta.isDocker) {
        policyPath = policyPath || root;
    }
    const policyLocations = [policyPath].concat(pluckPolicies(pkg))
        .filter(Boolean);
    const opts = { loose: true };
    const packageManager = meta.packageManager || 'npm';
    return api_token_1.exists('snyk monitor')
        .then(() => {
        if (policyLocations.length === 0) {
            return snyk.policy.create();
        }
        return snyk.policy.load(policyLocations, opts);
    }).then((policy) => {
        analytics.add('packageManager', packageManager);
        // TODO(kyegupov): async/await
        return new Promise((resolve, reject) => {
            request({
                body: {
                    meta: {
                        method: meta.method,
                        hostname: os.hostname(),
                        id: meta.id || snyk.id || pkg.name,
                        ci: isCI,
                        pid: process.pid,
                        node: process.version,
                        master: snyk.config.isMaster,
                        name: pkg.name,
                        version: pkg.version,
                        org: config.org ? decodeURIComponent(config.org) : undefined,
                        pluginName: pluginMeta.name,
                        pluginRuntime: pluginMeta.runtime,
                        dockerImageId: pluginMeta.dockerImageId,
                        dockerBaseImage: pkg.docker ? pkg.docker.baseImage : undefined,
                        projectName: meta['project-name'],
                    },
                    policy: policy.toString(),
                    package: pkg,
                    // we take the targetFile from the plugin,
                    // because we want to send it only for specific package-managers
                    targetFile: pluginMeta.targetFile,
                },
                gzip: true,
                method: 'PUT',
                headers: {
                    'authorization': 'token ' + snyk.api,
                    'content-encoding': 'gzip',
                },
                url: config.API + '/monitor/' + packageManager,
                json: true,
            }, (error, res, body) => {
                if (error) {
                    return reject(error);
                }
                if (res.statusCode === 200 || res.statusCode === 201) {
                    resolve(body);
                }
                else {
                    const e = new types_1.MonitorError('unexpected error: ' + body.message);
                    e.code = res.statusCode;
                    e.userMessage = body && body.userMessage;
                    if (!e.userMessage && res.statusCode === 504) {
                        e.userMessage = 'Connection Timeout';
                    }
                    reject(e);
                }
            });
        });
    });
}
exports.monitor = monitor;
function pluckPolicies(pkg) {
    if (!pkg) {
        return null;
    }
    if (pkg.snyk) {
        return pkg.snyk;
    }
    if (!pkg.dependencies) {
        return null;
    }
    return _.flatten(Object.keys(pkg.dependencies).map((name) => {
        return pluckPolicies(pkg.dependencies[name]);
    }).filter(Boolean));
}
//# sourceMappingURL=monitor.js.map